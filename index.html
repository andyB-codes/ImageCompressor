<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Image Size Compressor</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 24px; max-width: 920px; }
    h1 { margin: 0 0 8px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; }
    label { display: block; font-weight: 600; margin: 10px 0 6px; }
    input[type="number"], select, input[type="file"] {
      padding: 10px; border-radius: 10px; border: 1px solid #ccc; width: 240px;
    }
    button {
      padding: 10px 14px; border-radius: 10px; border: 1px solid #333; background: #111; color: #fff;
      cursor: pointer;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .muted { color: #666; font-size: 0.95rem; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 860px) { .grid { grid-template-columns: 1fr; } }
    img { max-width: 100%; border-radius: 12px; border: 1px solid #eee; }
    .stats { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .bar { height: 8px; background: #eee; border-radius: 999px; overflow: hidden; }
    .bar > div { height: 100%; background: #111; width: 0%; }
    .warn { color: #b00020; font-weight: 600; }
  </style>
</head>
<body>
  <h1>Image Size Compressor</h1>
  <p class="muted">
    Upload an image, enter a target file size, and download a compressed version.
    Runs entirely in your browser (no uploads).
  </p>

  <div class="card">
    <div class="row">
      <div>
        <label>Upload image</label>
        <input id="file" type="file" accept="image/*" />
      </div>

      <div>
        <label>Target size</label>
        <div class="row" style="gap:8px;">
          <input id="targetNum" type="number" min="1" value="250" />
          <select id="targetUnit">
            <option value="KB" selected>KB</option>
            <option value="MB">MB</option>
          </select>
        </div>
      </div>

      <div>
        <label>Output format</label>
        <select id="format">
          <option value="image/jpeg" selected>JPEG (.jpg)</option>
          <option value="image/webp">WebP (.webp)</option>
          <option value="image/png">PNG (.png, keeps alpha)</option>
        </select>
        <div class="muted">
          PNG has no “quality” slider. This app uses palette quantization + optional downscale to reach your target.
        </div>
      </div>

      <div>
        <label>Max dimension (optional)</label>
        <input id="maxDim" type="number" min="0" value="0" />
        <div class="muted">0 = keep original dimensions (unless needed).</div>
      </div>

      <div style="align-self:flex-end;">
        <button id="go" disabled>Compress</button>
      </div>
    </div>

    <div style="margin-top:14px;">
      <div class="bar"><div id="progress"></div></div>
      <div id="status" class="muted" style="margin-top:8px;"></div>
    </div>
  </div>

  <div class="grid" style="margin-top:16px;">
    <div class="card">
      <h3 style="margin-top:0;">Original</h3>
      <div class="stats" id="origStats">—</div>
      <img id="origPreview" alt="Original preview" />
    </div>

    <div class="card">
      <h3 style="margin-top:0;">Compressed</h3>
      <div class="stats" id="outStats">—</div>
      <div class="row" style="margin:10px 0;">
        <a id="download" style="display:none;">
          <button type="button">Download</button>
        </a>
        <span id="warning" class="warn" style="display:none;"></span>
      </div>
      <img id="outPreview" alt="Compressed preview" />
    </div>
  </div>

  <canvas id="c" style="display:none;"></canvas>

  <!-- PNG encoder with alpha + palette quantization -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script src="https://unpkg.com/upng-js@2.1.0/UPNG.js"></script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const fileInput = $("file");
  const btn = $("go");
  const status = $("status");
  const progress = $("progress");

  const origPreview = $("origPreview");
  const outPreview = $("outPreview");
  const origStats = $("origStats");
  const outStats = $("outStats");
  const download = $("download");
  const warning = $("warning");

  const canvas = $("c");
  const ctx = canvas.getContext("2d"); // keep alpha for PNG work

  let originalFile = null;
  let originalImageBitmap = null;

  const fmtBytes = (bytes) => {
    if (!Number.isFinite(bytes)) return "—";
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    return `${(kb / 1024).toFixed(2)} MB`;
  };

  const targetBytes = () => {
    const n = Math.max(1, Number($("targetNum").value || 1));
    const unit = $("targetUnit").value;
    return unit === "MB" ? n * 1024 * 1024 : n * 1024;
  };

  const setProgress = (p) => {
    const clamped = Math.max(0, Math.min(1, p));
    progress.style.width = `${(clamped * 100).toFixed(0)}%`;
  };

  const setStatus = (msg) => { status.textContent = msg; };

  fileInput.addEventListener("change", async (e) => {
    resetOutput();
    originalFile = e.target.files?.[0] || null;
    if (!originalFile) return;

    btn.disabled = true;
    setStatus("Loading image…");
    setProgress(0.1);

    const url = URL.createObjectURL(originalFile);
    origPreview.src = url;

    try {
      originalImageBitmap = await createImageBitmap(originalFile);
    } catch {
      originalImageBitmap = null;
    }

    const dims = await getImageDimensions(url);
    origStats.textContent = `${originalFile.name} — ${dims.w}×${dims.h} — ${fmtBytes(originalFile.size)}`;

    setProgress(0);
    setStatus("Ready.");
    btn.disabled = false;
  });

  $("format").addEventListener("change", resetOutput);
  $("targetNum").addEventListener("input", resetOutput);
  $("targetUnit").addEventListener("change", resetOutput);
  $("maxDim").addEventListener("input", resetOutput);

  function resetOutput() {
    outPreview.src = "";
    outStats.textContent = "—";
    download.style.display = "none";
    warning.style.display = "none";
    warning.textContent = "";
    setProgress(0);
  }

  async function getImageDimensions(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight });
      img.onerror = reject;
      img.src = url;
    });
  }

  async function getSourceImage() {
    let source = originalImageBitmap;
    if (!source) {
      const img = new Image();
      img.src = origPreview.src;
      await img.decode();
      source = img;
    }
    return source;
  }

  async function drawToCanvas(imgSource, maxDimension = 0, forceScale = 1) {
    const w0 = imgSource.width || imgSource.naturalWidth;
    const h0 = imgSource.height || imgSource.naturalHeight;

    let scale = forceScale;

    if (maxDimension > 0) {
      const m = Math.max(w0, h0);
      if (m > maxDimension) scale *= (maxDimension / m);
    }

    const w = Math.max(1, Math.round(w0 * scale));
    const h = Math.max(1, Math.round(h0 * scale));

    canvas.width = w;
    canvas.height = h;

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.clearRect(0, 0, w, h);
    ctx.drawImage(imgSource, 0, 0, w, h);

    return { w, h, scaleUsed: scale, w0, h0 };
  }

  function canvasToBlob(type, quality) {
    return new Promise((resolve) => canvas.toBlob(resolve, type, quality));
  }

  // --- NEW: PNG compressor (keeps alpha) using UPNG palette quantization + optional downscale ---
  async function encodePngWithColors(colors) {
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const rgba = imgData.data.buffer; // ArrayBuffer
    const pngBytes = UPNG.encode([rgba], canvas.width, canvas.height, colors);
    return new Blob([pngBytes], { type: "image/png" });
  }

  async function compressPngToTarget({ source, maxDimension, target }) {
    // You can tune these ladders depending on your images
    const colorSteps = [256, 192, 160, 128, 96, 64, 48, 32, 24, 16, 8];
    const scaleSteps = [1.0, 0.95, 0.90, 0.85, 0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30];

    let best = null;

    for (let s = 0; s < scaleSteps.length; s++) {
      const scale = scaleSteps[s];
      const drawInfo = await drawToCanvas(source, maxDimension, scale);

      setStatus(`PNG: scaling ${drawInfo.w}×${drawInfo.h}…`);
      setProgress(0.10 + (s / scaleSteps.length) * 0.25);

      // Try progressively fewer colors at this scale
      for (let i = 0; i < colorSteps.length; i++) {
        const colors = colorSteps[i];

        setStatus(`PNG: quantizing to ${colors} colors…`);
        setProgress(0.35 + (i / colorSteps.length) * 0.55);

        const blob = await encodePngWithColors(colors);
        if (!best || blob.size < best.blob.size) {
          best = { blob, colors, ...drawInfo };
        }

        if (blob.size <= target) {
          return { ...best, hitTarget: true };
        }
      }
    }

    return { ...best, hitTarget: best ? (best.blob.size <= target) : false };
  }

  async function compressLossyToTarget({ type, maxDimension, target }) {
    const source = await getSourceImage();

    let drawInfo = await drawToCanvas(source, maxDimension, 1);

    async function searchQuality() {
      let lo = 0.05, hi = 0.95;
      let best = null;

      for (let i = 0; i < 14; i++) {
        const q = (lo + hi) / 2;
        const blob = await canvasToBlob(type, q);
        if (!blob) break;

        setStatus(`Tuning quality… q=${q.toFixed(3)} size=${fmtBytes(blob.size)} target=${fmtBytes(target)}`);
        setProgress(0.15 + (i / 14) * 0.55);

        if (blob.size <= target) {
          best = { blob, q };
          lo = q;
        } else {
          hi = q;
        }
      }
      return best;
    }

    let best = await searchQuality();

    if (!best) {
      let scale = 0.9;
      for (let attempt = 0; attempt < 10; attempt++) {
        drawInfo = await drawToCanvas(source, maxDimension, scale);
        setStatus(`Scaling down… ${drawInfo.w}×${drawInfo.h}`);
        setProgress(0.7 + attempt * 0.02);

        best = await searchQuality();
        if (best) break;

        scale *= 0.85;
      }
    }

    if (!best) {
      const blob = await canvasToBlob(type, 0.05);
      return { blob, quality: 0.05, ...drawInfo, hitTarget: blob ? (blob.size <= target) : false };
    }

    return { blob: best.blob, quality: best.q, ...drawInfo, hitTarget: true };
  }

  btn.addEventListener("click", async () => {
    if (!originalFile) return;

    resetOutput();
    btn.disabled = true;

    const type = $("format").value;
    const maxDimension = Math.max(0, Number($("maxDim").value || 0));
    const target = targetBytes();

    setStatus("Compressing…");
    setProgress(0.05);

    try {
      const source = await getSourceImage();
      let result;

      if (type === "image/png") {
        // PNG path (keeps alpha)
        if (!window.UPNG) throw new Error("UPNG.js failed to load.");
        result = await compressPngToTarget({ source, maxDimension, target });
      } else {
        // JPEG / WebP path
        result = await compressLossyToTarget({ type, maxDimension, target });
      }

      setProgress(1);
      setStatus("Done.");

      if (!result || !result.blob) throw new Error("Failed to encode image.");

      const outUrl = URL.createObjectURL(result.blob);
      outPreview.src = outUrl;

      const ext = (type === "image/webp") ? "webp" : (type === "image/png" ? "png" : "jpg");
      const base = (originalFile.name || "image").replace(/\.[^.]+$/, "");

      const approxKb = Math.round(result.blob.size / 1024);
      const outName = `${base}_~${approxKb}KB.${ext}`;

      const extra =
        type === "image/png"
          ? `colors=${result.colors ?? "?"}`
          : `q=${(result.quality ?? 0).toFixed(3)}`;

      outStats.textContent =
        `${outName} — ${result.w}×${result.h} — ${extra} — ${fmtBytes(result.blob.size)} (target ${fmtBytes(target)})`;

      download.href = outUrl;
      download.download = outName;
      download.style.display = "inline-block";

      if (result.blob.size > target) {
        warning.style.display = "inline";
        warning.textContent =
          "Could not reach the target size with acceptable PNG constraints; try increasing target or allowing more downscale.";
      }

    } catch (err) {
      console.error(err);
      setProgress(0);
      setStatus("Error: " + (err?.message || String(err)));
    } finally {
      btn.disabled = false;
    }
  });
})();
</script>
</body>
</html>
