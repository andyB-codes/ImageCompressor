<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Image Size Compressor</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 24px; max-width: 920px; }
    h1 { margin: 0 0 8px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; }
    label { display: block; font-weight: 600; margin: 10px 0 6px; }
    input[type="number"], select, input[type="file"] {
      padding: 10px; border-radius: 10px; border: 1px solid #ccc; width: 240px;
    }
    button {
      padding: 10px 14px; border-radius: 10px; border: 1px solid #333; background: #111; color: #fff;
      cursor: pointer;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .muted { color: #666; font-size: 0.95rem; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 860px) { .grid { grid-template-columns: 1fr; } }
    img { max-width: 100%; border-radius: 12px; border: 1px solid #eee; }
    .stats { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .bar { height: 8px; background: #eee; border-radius: 999px; overflow: hidden; }
    .bar > div { height: 100%; background: #111; width: 0%; }
    .warn { color: #b00020; font-weight: 600; }
  </style>
</head>
<body>
  <h1>Image Size Compressor</h1>
  <p class="muted">
    Upload an image, enter a target file size, and download a compressed version.
    Runs entirely in your browser (no uploads).
  </p>

  <div class="card">
    <div class="row">
      <div>
        <label>Upload image</label>
        <input id="file" type="file" accept="image/*" />
      </div>

      <div>
        <label>Target size</label>
        <div class="row" style="gap:8px;">
          <input id="targetNum" type="number" min="1" value="250" />
          <select id="targetUnit">
            <option value="KB" selected>KB</option>
            <option value="MB">MB</option>
          </select>
        </div>
      </div>

      <div>
        <label>Output format</label>
        <select id="format">
          <option value="image/jpeg" selected>JPEG (.jpg)</option>
          <option value="image/webp">WebP (.webp)</option>
        </select>
        <div class="muted">PNG is lossless → not ideal for hitting a size.</div>
      </div>

      <div>
        <label>Max dimension (optional)</label>
        <input id="maxDim" type="number" min="0" value="0" />
        <div class="muted">0 = keep original dimensions (unless needed).</div>
      </div>

      <div style="align-self:flex-end;">
        <button id="go" disabled>Compress</button>
      </div>
    </div>

    <div style="margin-top:14px;">
      <div class="bar"><div id="progress"></div></div>
      <div id="status" class="muted" style="margin-top:8px;"></div>
    </div>
  </div>

  <div class="grid" style="margin-top:16px;">
    <div class="card">
      <h3 style="margin-top:0;">Original</h3>
      <div class="stats" id="origStats">—</div>
      <img id="origPreview" alt="Original preview" />
    </div>

    <div class="card">
      <h3 style="margin-top:0;">Compressed</h3>
      <div class="stats" id="outStats">—</div>
      <div class="row" style="margin:10px 0;">
        <a id="download" style="display:none;">
          <button type="button">Download</button>
        </a>
        <span id="warning" class="warn" style="display:none;"></span>
      </div>
      <img id="outPreview" alt="Compressed preview" />
    </div>
  </div>

  <canvas id="c" style="display:none;"></canvas>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const fileInput = $("file");
  const btn = $("go");
  const status = $("status");
  const progress = $("progress");

  const origPreview = $("origPreview");
  const outPreview = $("outPreview");
  const origStats = $("origStats");
  const outStats = $("outStats");
  const download = $("download");
  const warning = $("warning");

  const canvas = $("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  let originalFile = null;
  let originalImageBitmap = null;

  const fmtBytes = (bytes) => {
    if (!Number.isFinite(bytes)) return "—";
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    return `${(kb / 1024).toFixed(2)} MB`;
  };

  const targetBytes = () => {
    const n = Math.max(1, Number($("targetNum").value || 1));
    const unit = $("targetUnit").value;
    return unit === "MB" ? n * 1024 * 1024 : n * 1024;
  };

  const setProgress = (p) => {
    const clamped = Math.max(0, Math.min(1, p));
    progress.style.width = `${(clamped * 100).toFixed(0)}%`;
  };

  const setStatus = (msg) => { status.textContent = msg; };

  fileInput.addEventListener("change", async (e) => {
    resetOutput();
    originalFile = e.target.files?.[0] || null;
    if (!originalFile) return;

    btn.disabled = true;
    setStatus("Loading image…");
    setProgress(0.1);

    const url = URL.createObjectURL(originalFile);
    origPreview.src = url;

    // Use createImageBitmap for speed + correct orientation in many browsers
    try {
      originalImageBitmap = await createImageBitmap(originalFile);
    } catch {
      originalImageBitmap = null;
    }

    // Get dimensions
    const dims = await getImageDimensions(url);
    origStats.textContent = `${originalFile.name} — ${dims.w}×${dims.h} — ${fmtBytes(originalFile.size)}`;

    setProgress(0);
    setStatus("Ready.");
    btn.disabled = false;
  });

  $("format").addEventListener("change", resetOutput);
  $("targetNum").addEventListener("input", resetOutput);
  $("targetUnit").addEventListener("change", resetOutput);
  $("maxDim").addEventListener("input", resetOutput);

  function resetOutput() {
    outPreview.src = "";
    outStats.textContent = "—";
    download.style.display = "none";
    warning.style.display = "none";
    warning.textContent = "";
    setProgress(0);
  }

  async function getImageDimensions(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight });
      img.onerror = reject;
      img.src = url;
    });
  }

  async function drawToCanvas(imgSource, maxDimension = 0, forceScale = 1) {
    // imgSource can be ImageBitmap or HTMLImageElement
    const w0 = imgSource.width || imgSource.naturalWidth;
    const h0 = imgSource.height || imgSource.naturalHeight;

    let scale = forceScale;

    if (maxDimension > 0) {
      const m = Math.max(w0, h0);
      if (m > maxDimension) scale *= (maxDimension / m);
    }

    const w = Math.max(1, Math.round(w0 * scale));
    const h = Math.max(1, Math.round(h0 * scale));

    canvas.width = w;
    canvas.height = h;

    // High-quality downsampling
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.clearRect(0, 0, w, h);
    ctx.drawImage(imgSource, 0, 0, w, h);

    return { w, h, scaleUsed: scale, w0, h0 };
  }

  function canvasToBlob(type, quality) {
    return new Promise((resolve) => canvas.toBlob(resolve, type, quality));
  }

  async function compressToTarget({
    type,
    maxDimension,
    target,
    preferScaleDown = true
  }) {
    // Step 1: draw initial image (respecting maxDimension if set)
    let source = originalImageBitmap;
    if (!source) {
      // Fallback: load into an Image element
      const img = new Image();
      img.src = origPreview.src;
      await img.decode();
      source = img;
    }

    // Optional initial maxDimension
    let drawInfo = await drawToCanvas(source, maxDimension, 1);

    // Step 2: binary search quality at current dimensions
    async function searchQuality() {
      let lo = 0.05, hi = 0.95;   // practical bounds
      let best = null;

      for (let i = 0; i < 14; i++) { // ~14 iterations is plenty
        const q = (lo + hi) / 2;
        const blob = await canvasToBlob(type, q);
        if (!blob) break;

        setStatus(`Tuning quality… q=${q.toFixed(3)} size=${fmtBytes(blob.size)} target=${fmtBytes(target)}`);
        setProgress(0.15 + (i / 14) * 0.55);

        if (blob.size <= target) {
          best = { blob, q };
          lo = q; // try higher quality
        } else {
          hi = q; // need smaller
        }
      }
      return best;
    }

    let best = await searchQuality();

    // If quality search can't get under target, scale down dimensions and retry.
    // This is common when target is very small.
    if (!best && preferScaleDown) {
      let scale = 0.9;
      for (let attempt = 0; attempt < 10; attempt++) {
        drawInfo = await drawToCanvas(source, maxDimension, scale);
        setStatus(`Scaling down… ${drawInfo.w}×${drawInfo.h}`);
        setProgress(0.7 + attempt * 0.02);

        best = await searchQuality();
        if (best) break;

        scale *= 0.85; // progressively more aggressive
      }
    }

    // Last resort: return lowest-quality attempt even if > target
    if (!best) {
      const blob = await canvasToBlob(type, 0.05);
      return { blob, quality: 0.05, ...drawInfo, hitTarget: blob ? (blob.size <= target) : false };
    }

    return { blob: best.blob, quality: best.q, ...drawInfo, hitTarget: true };
  }

  btn.addEventListener("click", async () => {
    if (!originalFile) return;

    resetOutput();
    btn.disabled = true;

    const type = $("format").value;
    const maxDimension = Math.max(0, Number($("maxDim").value || 0));
    const target = targetBytes();

    setStatus("Compressing…");
    setProgress(0.05);

    try {
      const result = await compressToTarget({ type, maxDimension, target });

      setProgress(1);
      setStatus("Done.");

      if (!result.blob) throw new Error("Failed to encode image.");

      const outUrl = URL.createObjectURL(result.blob);
      outPreview.src = outUrl;

      const ext = (type === "image/webp") ? "webp" : "jpg";
      const base = (originalFile.name || "image").replace(/\.[^.]+$/, "");
      const outName = `${base}_~${Math.round(result.blob.size/1024)}KB.${ext}`;

      outStats.textContent =
        `${outName} — ${result.w}×${result.h} — q=${result.quality.toFixed(3)} — ${fmtBytes(result.blob.size)} (target ${fmtBytes(target)})`;

      download.href = outUrl;
      download.download = outName;
      download.style.display = "inline-block";

      if (result.blob.size > target) {
        warning.style.display = "inline";
        warning.textContent = "Could not reach the target size without extreme degradation; consider increasing target or allowing more scaling.";
      }

    } catch (err) {
      console.error(err);
      setProgress(0);
      setStatus("Error: " + (err?.message || String(err)));
    } finally {
      btn.disabled = false;
    }
  });
})();
</script>
</body>
</html>
